const t=[];for(let n=0;n<256;++n)t.push((n+256).toString(16).slice(1));function o(n,e=0){return(t[n[e+0]]+t[n[e+1]]+t[n[e+2]]+t[n[e+3]]+"-"+t[n[e+4]]+t[n[e+5]]+"-"+t[n[e+6]]+t[n[e+7]]+"-"+t[n[e+8]]+t[n[e+9]]+"-"+t[n[e+10]]+t[n[e+11]]+t[n[e+12]]+t[n[e+13]]+t[n[e+14]]+t[n[e+15]]).toLowerCase()}let c;const U=new Uint8Array(16);function l(){if(!c){if(typeof crypto=="undefined"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");c=crypto.getRandomValues.bind(crypto)}return c(U)}const a=typeof crypto!="undefined"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var m={randomUUID:a};function p(n,e,d){var i,y,g;if(m.randomUUID&&!e&&!n)return m.randomUUID();n=n||{};const r=(g=(y=n.random)!=null?y:(i=n.rng)==null?void 0:i.call(n))!=null?g:l();if(r.length<16)throw new Error("Random bytes length must be >= 16");if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,e){if(d=d||0,d<0||d+16>e.length)throw new RangeError(`UUID byte range ${d}:${d+15} is out of buffer bounds`);for(let u=0;u<16;++u)e[d+u]=r[u];return e}return o(r)}export{p as v};
